# Phase 12 Retrospective: User Story 10 — Observer System

## What Worked Well
- TDD approach caught test-implementation mismatches early (triage trigger types)
- Parallel subagent execution for triage.ts and nudge.ts saved significant time
- Clean separation: triage.ts (API call), nudge.ts (WebSocket broadcast), observer.ts (orchestration)
- EventEmitter-based architecture from Phase 6 paid off — Observer subscribes cleanly to action events
- Fake timers (vi.useFakeTimers) enabled deterministic testing of cooldown and flow state windows

## What Didn't Work
- Suppression test initially used non-trigger action types (file_save, editor_tab_switch) as triage triggers — contradicted the triage test and spec. Required manual fixes.
- Test mock for deliverNudge wasn't cleared before flow state assertions — caused false failure
- `as ActionType` unnecessary type assertion caught by ESLint (ActionEventPayload.actionType is already ActionType)
- Duplicate import lint errors when splitting type/value imports across two lines

## Workarounds & Solutions
- **logAction with null db**: Observer uses `logAction(db as never, ...)` to call logAction even when getDatabase() returns null. In production db is always available; in tests logAction is mocked so the db value doesn't matter.
- **Triage trigger vs flow state distinction**: Triage triggers (file_open, buffer updates, explain requests, phase_completed) are a DIFFERENT list from flow state user-initiated actions (buffer_summary, buffer_significant_change, file_open, file_save, editor_tab_switch). Must keep these separate.
- **Mock clear timing**: When testing flow state, must clear BOTH mockRunTriage and mockDeliverNudge after the setup loop, not just mockRunTriage.

## Packages & Dependencies
- No new dependencies needed — Observer uses existing EventEmitter, callApi, broadcast infrastructure

## Patterns & Code
- **Observer constructor options pattern**: All tuneable parameters (cooldownMs, flowStateThreshold, etc.) as optional with defaults. Allows tests to override without affecting production defaults.
- **Flow state sliding window**: Push timestamps to array, filter by `now - t <= windowMs`. Simple and effective.
- **Triage trigger counting**: Map-like counters (bufferUpdateCount, explainRequestCount) with modular reset on reaching threshold. Buffer counter resets on phase_completed; explain counter never resets.
- **Module-level Observer singleton**: `let activeObserver: Observer | null` in lifecycle.ts with `getActiveObserver()` export for cross-module access (WebSocket handler).
- **void this.handleAction()**: EventEmitter listener calls async method with `void` prefix to handle fire-and-forget pattern without require-await lint errors.

## For Next Time
- Validate that test files use only spec-defined trigger types before committing tests
- When writing parallel test suites that test the same module, ensure both agree on the API contract
- Consider adding a "triage trigger check" utility function to avoid hardcoding trigger logic in tests
