# Phase 6 Retrospective: Action Logging & Observability (US4)

## What Worked Well
- Phase 2 foundational work (logAction, actionEvents, logApiCall) was already complete, making this phase lightweight
- Parallel subagents for buffer summary and action queries implementations worked well
- TDD stubs using `function returning Promise.reject()` pattern continued to work cleanly with ESLint
- All 21 new tests passed on first implementation attempt (after id DESC tiebreaker fix)

## What Didn't Work
- SQLite `ORDER BY created_at DESC` is non-deterministic when multiple rows have identical timestamps (sub-millisecond inserts in tests)

## Workarounds & Solutions
- Added `ORDER BY id DESC` as tiebreaker in `getRecentActions` query to ensure deterministic ordering when created_at values match
- BufferLogState uses module-level Map with `resetBufferLogState()` export for test isolation

## Packages & Dependencies
- No new dependencies needed — all US4 functionality built on existing Kysely + better-sqlite3 + EventEmitter

## Patterns & Code
- `BufferLogState` pattern: `Map<filePath, { lastLoggedCharCount, editCountSinceLastLog }>` for tracking buffer changes between logging intervals
- Significant change threshold: `|delta| > 500 || (delta / lastCount) > 0.5` with special case for `lastCount === 0` (first edit)
- SQL aggregation with COALESCE: `COALESCE(SUM(cost_estimate), 0)` ensures zero instead of null for empty result sets
- ApiCallStats query pattern: `Number()` wrapper on aggregation results to handle potential BigInt from SQLite

## For Next Time
- When writing ORDER BY queries for time-based data, always include an `id` tiebreaker column
- Phase was fast because foundational work was solid — keep investing in Phase 2 foundations
