# Phase 9 Retrospective: User Story 7 - Claude API Client

## What Worked Well
- Parallel subagent execution for models.ts (unit) and claude.ts (integration) — both completed independently
- TDD stubs with `Promise.reject(new Error('Not implemented'))` pattern continues to work well
- Clean separation: models.ts is pure/synchronous, claude.ts is async with side effects
- Integration tests with mocked Anthropic SDK + real SQLite provide good coverage without live API calls
- Lazy singleton pattern for Anthropic client accommodates test env setup timing

## What Didn't Work
- T234-T241 tasks were overly granular (separate tasks for error classes + logging that were already part of claude.ts implementation)
- Spec calls for `zodOutputFormat` structured outputs but manual JSON parse + Zod validate works better with mocked tests

## Workarounds & Solutions
- **Lazy client initialization**: `getClient()` reads `ANTHROPIC_API_KEY` on first call, not at import time — allows tests to set env var in `beforeEach`
- **Null db guard**: `getDatabase()` can return null, so `logApiCall` calls are guarded with `if (db !== null)`
- **Double-log prevention**: Known API errors (ApiRefusalError, ApiMaxTokensError) are re-thrown in catch block without re-logging
- **Manual JSON parse**: Instead of `zodOutputFormat` constrained decoding, parse `response.content[0].text` as JSON then `schema.parse()` — works with both mock and real responses

## Packages & Dependencies
- No new packages needed — `@anthropic-ai/sdk` and `zod` were already installed
- `@anthropic-ai/sdk` provides `Anthropic` class with `messages.create()` that returns typed responses with `usage`, `stop_reason`, `content`

## Patterns & Code
- **callApi flow**: resolveModel → compute inputHash → SDK call → check stop_reason → parse JSON → validate Zod → compute cost → logApiCall → return
- **Failure logging**: `logFailure()` helper with sentinel values (latencyMs=-1, zero tokens) used consistently for refusal, max_tokens, and unexpected errors
- **Input hash**: `createHash('sha256').update(userMessage).digest('hex').slice(0, 16)` for observability
- **Cost formula**: `(inputTokens * pricing.inputPerMillion + outputTokens * pricing.outputPerMillion) / 1_000_000`

## For Next Time
- Collapse granular tasks (T234-T241) into 2 tasks: "implement models.ts" and "implement claude.ts" — error classes and logging are integral parts
- Consider testing with real API calls in a separate test suite (requires ANTHROPIC_API_KEY)
