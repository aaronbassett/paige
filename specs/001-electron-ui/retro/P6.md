# Phase 6 Retrospective: Terminal with xterm.js

## What Worked Well
- **2-agent parallel launch** for main process (PTY Manager + Service + IPC) and renderer (Terminal Component + Theme) — both agents produced clean, compatible code independently
- **IPC channel design**: Simple `terminal:write`/`terminal:resize`/`terminal:data`/`terminal:exit` channels cleanly separate concerns between main and renderer process
- **xterm.js + FitAddon**: Straightforward integration. `Terminal.open(container)` + `FitAddon.fit()` + `ResizeObserver` gives automatic sizing with no extra work
- **Existing patterns transfer**: WebSocket hook, handler-capture test pattern, and mock strategies from prior phases applied directly

## What Didn't Work
- **Dual Window type declarations**: Both `global.d.ts` and `types/window.d.ts` declare `Window.paige`. TypeScript merges them via declaration merging but the optional vs required typing mismatch could be confusing
- **PTY listener cleanup gap**: `window.paige.terminal.onData/onExit` accept callbacks but don't return unsubscribe functions. Callbacks linger after terminal unmount (mitigated by terminal dispose stopping writes)

## Workarounds & Solutions
- **isDestroyed() guard in pty-service**: Prevents Electron crash when `webContents.send()` is called on a destroyed BrowserWindow during shutdown race conditions
- **requestAnimationFrame in ResizeObserver**: Standard xterm.js pattern to prevent layout thrashing during resize cycles
- **Constructor functions in test mocks**: Vitest 4 requires `function` keyword (not arrow functions) for `new`-able mock classes

## Packages & Dependencies
- **@xterm/xterm**: Clean API. `Terminal` + `FitAddon` combo handles all rendering, sizing, and ANSI parsing. `ITheme` provides full color customization
- **node-pty**: `import * as pty from 'node-pty'` works under ESM + esModuleInterop. `onData`/`onExit` return `IDisposable` for clean listener management

## Patterns & Code
- **PTY lifecycle singleton**: `PtyManager` class with spawn/write/resize/kill + `isAlive` getter. Single data/exit listener at a time (dispose previous on re-registration)
- **IPC bridge pattern**: Main process → `ipcMain.on()` handlers call PtyManager methods; PTY output → `webContents.send()` to renderer; Preload → `contextBridge.exposeInMainWorld` with `ipcRenderer.send`/`.on` wrappers
- **Terminal + WebSocket dual communication**: Terminal uses IPC for PTY data flow AND WebSocket for backend state signaling (`terminal:ready`, `terminal:resize`, `observer:nudge`)
- **Observer nudge flow**: WebSocket message → renderer `on('observer:nudge')` handler → `ptyBridge.write()` → PTY stdin → appears as normal terminal output

## For Next Time
- **Add unsubscribe to PTY bridge**: Return cleanup functions from `onData`/`onExit` in preload to enable proper cleanup
- **Phase 6 was fast**: Terminal is a relatively self-contained component with clear boundaries (IPC for PTY, WebSocket for backend). Good candidate for single-session completion
- **Mock constructor pattern**: Always use `function` keyword, not arrow functions, for mocked classes that will be `new`-ed in Vitest
