# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Paige is an AI-powered coaching tool for junior developers. Instead of writing code for developers, Paige coaches them through problems. The tagline: "Claude Codes, Paige Pairs."

This is a hackathon project (one-week, solo developer) for the Claude Code Hackathon at Cerebral Valley. Judging is 30% demo, 25% impact, 25% Opus 4.6 use, 20% depth & execution.

## Architecture: Three Tiers

```
Claude Code Plugin ←── MCP (SSE) ──→ Backend Server ←── WebSocket ──→ Electron UI
  (Personality)                        (Brain)                         (Face)
```

**Claude Code Plugin**: Coaching persona, read-only enforcement via hooks, prompt enrichment. Uses SessionStart, PreToolUse, PostToolUse, UserPromptSubmit, and Stop hooks.

**Backend Server**: Node.js/TypeScript. Owns ALL state (SQLite for structured data, ChromaDB for semantic search), all file I/O, all MCP tool implementations, action logging. Single source of truth — if the backend doesn't know about it, it didn't happen.

**Electron UI**: Thin rendering client. React + TypeScript. Monaco Editor for code, xterm.js for terminal, file tree with hint decorations. Communicates with backend via WebSocket only. NEVER touches the filesystem directly. Contains no AI logic.

## Active Technologies

**Language & Runtime**: TypeScript on Node.js 18+

**Core Dependencies**:
- `@modelcontextprotocol/sdk` - MCP Streamable HTTP transport for Claude Code integration
- `better-sqlite3` + `kysely` - Type-safe SQLite database access
- `ws` - WebSocket server for Electron communication
- `chokidar` - File system watching
- `zod` - Runtime schema validation for Claude API structured outputs
- `@anthropic-ai/sdk` - Claude API client
- `chromadb` - Semantic memory with graceful degradation

**Storage**:
- SQLite (`{DATA_DIR}/paige.db`) - 10 tables for sessions, plans, phases, hints, progress, gaps, katas, actions, API calls
- ChromaDB (`localhost:8000`) - Semantic memory for cross-session learning
- In-memory - Buffer cache, open files, WebSocket connections, MCP sessions

**Testing**: Vitest (fast, ESM-native, TypeScript-first)

**Architecture**: Single backend server, three-tier system (Plugin ↔ Backend ↔ Electron)

## Development Commands

### Essential Commands

```bash
# Install dependencies
pnpm install

# Start dev server with hot reload
pnpm dev

# Run all tests
pnpm test

# Type check
pnpm typecheck

# Lint
pnpm lint

# Format
pnpm format

# Build for production
pnpm build
```

### Testing Commands

```bash
# Watch mode
pnpm test:watch

# Unit tests only (fast, isolated, mocked dependencies)
pnpm test:unit

# Integration tests (real SQLite, file system, WebSocket)
pnpm test:integration

# Contract tests (MCP/WebSocket protocol conformance)
pnpm test:contract

# Coverage report
pnpm test:coverage
```

### Database Commands

```bash
# Reset database (deletes all data)
rm ~/.paige/paige.db
# Server will recreate on next start

# Query database directly
sqlite3 ~/.paige/paige.db "SELECT * FROM sessions;"
```

### External Services

```bash
# Start ChromaDB (optional, server degrades gracefully without it)
docker run -p 8000:8000 chromadb/chroma

# Check GitHub CLI auth (optional, for issue fetching)
gh auth status
```

## File Structure

### Implementation Plan Documents

```
specs/002-backend-server/
├── spec.md         # Complete functional requirements (12 user stories)
├── plan.md         # This implementation plan
├── research.md     # Technology decisions and best practices
├── data-model.md   # Database schema and entity relationships
├── quickstart.md   # Setup and testing guide
├── contracts/      # API contracts
│   ├── mcp-tools.json     # 12 MCP tool schemas
│   └── websocket.json     # 55 WebSocket message types
└── tasks.md        # Generated by /sdd:tasks (not yet created)
```

### Source Code (when implemented)

```
src/
├── index.ts        # Entry point: HTTP + MCP + WebSocket
├── config/         # Environment validation
├── database/       # Kysely setup, migrations, typed queries
├── file-system/    # Buffer cache, file ops, watcher, tree
├── logger/         # Action log, API log
├── mcp/            # MCP server, 12 tools, session management
├── websocket/      # WebSocket server, router, 23 handlers
├── api-client/     # Claude API with retries, schemas, pricing
├── memory/         # ChromaDB client with degradation
├── coaching/       # Pipeline, wrap-up, 4 agents
├── observer/       # Per-session Observer, triage, nudges
├── ui-apis/        # Explain This, Practice Review
├── dashboard/      # Dashboard data assembly (4 flows)
└── types/          # TypeScript definitions
```

## Recent Changes

**2026-02-11** - Initial planning phase completed
- Defined 12 user stories with 186 functional requirements
- Researched tech stack (Vitest, Kysely, MCP SDK, ChromaDB)
- Designed data model (10 tables with relationships)
- Generated API contracts (12 MCP tools, 55 WebSocket messages)
- Created quickstart guide with setup instructions

## References

- `docs/planning/initial-brainstorm.md` — Full architecture, research, UI design, coaching pipeline, MCP tool surface, WebSocket protocol, Observer system, demo script (Read when required)
- `.sdd/memory/constitution.md` — Project constitution with enforceable principles and development standards (Read at the start of every session)
- `specs/002-backend-server/spec.md` — Complete feature specification (12 user stories, 186 requirements, 91 success criteria)
- `specs/002-backend-server/plan.md` — Implementation plan with technical decisions
- `specs/002-backend-server/data-model.md` — Database schema and entity relationships
- `specs/002-backend-server/quickstart.md` — Setup and testing guide
